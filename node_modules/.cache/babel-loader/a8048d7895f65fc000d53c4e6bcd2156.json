{"ast":null,"code":"import { readAllData, clearAllData } from './db';\n\nconst Cryptr = require('cryptr');\n\nconst cryptr = new Cryptr('GenericKey');\n\nconst Base64 = require('js-base64').Base64;\n\nlet encrypt = data => {\n  return \"encrypt_data_\" + cryptr.encrypt(data);\n};\n\nlet decrypt = data => {\n  if (data == null || data == undefined || data == \"\") {\n    return \"\";\n  } else {\n    //check if original string is encryptable\n    if (data.length > 13 && data.substring(0, 13) === \"encrypt_data_\") {\n      let decryptme = data.substring(13);\n      return cryptr.decrypt(decryptme);\n    } else {\n      return data;\n    }\n  }\n};\n\nlet checkPermissions = key => {\n  return readAllData('session').then(function (session) {\n    let isAllowed = false;\n    let permissionsList = session.permissions;\n\n    if (permissionsList != null && permissionsList.length > 0) {\n      permissionsList.forEach(function (permissions, i) {\n        if (permissions.name === key) {\n          isAllowed = true;\n        }\n      });\n    }\n\n    return isAllowed;\n  });\n};\n\nlet getSessionInfo = () => {\n  return new Promise(function (resolve, reject) {\n    resolve(readAllData('session'));\n  });\n};\n\nlet checkLogin = props => {\n  return new Promise(function (resolve, reject) {\n    readAllData('session').then(function (session) {\n      if (session.length > 0 && session[0].access_token !== \"\" && session[0].access_token !== undefined) {\n        console.log(\"SHOULD GO IN\");\n        console.log(session);\n        resolve(false);\n      } else {\n        console.log(\"SHOULD NOT GO IN\");\n        resolve(true);\n      }\n    }).catch(function (err) {\n      console.log(\"SHOULD NOT GO IN\");\n      resolve(true);\n    });\n  });\n};\n\nlet inArray = (needle, haystack) => {\n  var length = haystack.length;\n\n  for (var i = 0; i < length; i++) {\n    if (haystack[i] == needle) return true;\n  }\n\n  return false;\n};\n\nlet isManager = roles => {\n  if (roles === undefined || roles === null) {\n    return false;\n  } else {\n    roles = roles.toLowerCase();\n    let fa_roles = [\"agency partner\", \"insurance specialist\", \"financial advisor\"];\n    console.log(roles); //return false;\n\n    return !inArray(roles, fa_roles);\n  }\n};\n\nlet passwordFormat = pass => {\n  /**\n   * Password policy\n   * Must meet the following criterion:\n   * 1 uppercase character, 1 lowercase character\n   * 1 digit, 1 special character\n   * At least 8 characters long\n   * Max 128 characters long\n   *\n   * (special characters from this list https://www.owasp.org/index.php/Password_special_characters)\n   * (128 chars as stated here https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md)\n   *  @constant\n   *  @type {regex}\n   */\n  const passRegEx = /^(?=.*[0-9])(?=.*[A-Z])(?=.*[a-z])(?=.*[\\!\"#\\$%&'\\(\\)\\*\\+,-\\.\\/:;<=>\\?@\\[\\\\\\]\\^_`\\{\\|\\}~])[\\w!\\!\"#\\$%&'\\(\\)\\*\\+,-\\.\\/:;<=>\\?@\\[\\\\\\]\\^_`\\{\\|\\}~]{8,128}$/;\n  if (passRegEx.test(pass)) return true;else return false;\n};\n\nconst isSessionExpired = async response => {\n  let expired = false;\n\n  if (response.result == \"error\" && (response.message.toLowerCase() == \"Invalid Access Token\".toLowerCase() || response.message.toLowerCase() == \"Invalid or Expired Access Token\".toLowerCase())) {\n    expired = true;\n    console.log(\"session is expired\");\n    await clearUsersDb(expired);\n  }\n\n  return expired;\n};\n\nconst clearUsersDb = async isExpired => {\n  if (isExpired) {\n    await clearAllData('users');\n    console.log(\"Expired, clearing users\");\n  }\n\n  console.log(\"Not expired, not clearing users\");\n};\n\nexport { passwordFormat, encrypt, decrypt, isManager, checkPermissions, checkLogin, getSessionInfo, isSessionExpired };","map":{"version":3,"sources":["/Users/larainefajardo/Desktop/web_app/_progressive_web_app/react/companion/src/utils/security.js"],"names":["readAllData","clearAllData","Cryptr","require","cryptr","Base64","encrypt","data","decrypt","undefined","length","substring","decryptme","checkPermissions","key","then","session","isAllowed","permissionsList","permissions","forEach","i","name","getSessionInfo","Promise","resolve","reject","checkLogin","props","access_token","console","log","catch","err","inArray","needle","haystack","isManager","roles","toLowerCase","fa_roles","passwordFormat","pass","passRegEx","test","isSessionExpired","response","expired","result","message","clearUsersDb","isExpired"],"mappings":"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","sourcesContent":["import { readAllData, clearAllData } from './db'\n\nconst Cryptr = require('cryptr');\nconst cryptr = new Cryptr('GenericKey');\nconst Base64 = require('js-base64').Base64;\n\n\nlet encrypt = (data) => {\n  return \"encrypt_data_\" + cryptr.encrypt(data);\n}\n\nlet decrypt = (data) => {\n  if (data == null || data == undefined || data == \"\") {\n    return \"\";\n  } else {\n    //check if original string is encryptable\n    if (data.length > 13 && data.substring(0, 13) === \"encrypt_data_\") {\n      let decryptme = data.substring(13);\n      return cryptr.decrypt(decryptme);\n    } else {\n      return data;\n    }\n  }\n}\n\nlet checkPermissions = (key) => {\n  return readAllData('session').then(function (session) {\n\n    let isAllowed = false;\n    let permissionsList = session.permissions;\n\n    if (permissionsList != null && permissionsList.length > 0) {\n      permissionsList.forEach(function (permissions, i) {\n        if (permissions.name === key) {\n          isAllowed = true;\n        }\n      });\n    }\n    return isAllowed;\n  });\n}\n\nlet getSessionInfo = () => {\n  return new Promise(function (resolve, reject) {\n    resolve(readAllData('session'));\n  });\n}\n\nlet checkLogin = (props) => {\n\n  return new Promise(function (resolve, reject) {\n    readAllData('session').then(function (session) {\n      if (session.length > 0 && session[0].access_token !== \"\" && session[0].access_token !== undefined) {\n        console.log(\"SHOULD GO IN\");\n        console.log(session);\n        resolve(false);\n      } else {\n        console.log(\"SHOULD NOT GO IN\");\n        resolve(true);\n      }\n    }).catch(function (err) {\n      console.log(\"SHOULD NOT GO IN\");\n      resolve(true);\n    })\n  });\n}\n\nlet inArray = (needle, haystack) => {\n  var length = haystack.length;\n  for (var i = 0; i < length; i++) {\n    if (haystack[i] == needle) return true;\n  }\n  return false;\n}\n\n\nlet isManager = (roles) => {\n  if (roles === undefined || roles === null) {\n    return false;\n  } else {\n    roles = roles.toLowerCase();\n    let fa_roles = [\"agency partner\", \"insurance specialist\", \"financial advisor\"]\n    console.log(roles);\n    //return false;\n    return !(inArray(roles, fa_roles));\n  }\n}\n\nlet passwordFormat = (pass) => {\n  /**\n   * Password policy\n   * Must meet the following criterion:\n   * 1 uppercase character, 1 lowercase character\n   * 1 digit, 1 special character\n   * At least 8 characters long\n   * Max 128 characters long\n   *\n   * (special characters from this list https://www.owasp.org/index.php/Password_special_characters)\n   * (128 chars as stated here https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md)\n   *  @constant\n   *  @type {regex}\n   */\n  const passRegEx = /^(?=.*[0-9])(?=.*[A-Z])(?=.*[a-z])(?=.*[\\!\"#\\$%&'\\(\\)\\*\\+,-\\.\\/:;<=>\\?@\\[\\\\\\]\\^_`\\{\\|\\}~])[\\w!\\!\"#\\$%&'\\(\\)\\*\\+,-\\.\\/:;<=>\\?@\\[\\\\\\]\\^_`\\{\\|\\}~]{8,128}$/;\n\n  if (passRegEx.test(pass))\n    return true;\n  else\n    return false;\n}\n\nconst isSessionExpired = async (response) => {\n  let expired = false;\n  if (\n    response.result == \"error\" && (\n      response.message.toLowerCase() == \"Invalid Access Token\".toLowerCase()\n      || response.message.toLowerCase() == \"Invalid or Expired Access Token\".toLowerCase()\n    )\n  ) {\n    expired = true;\n    console.log(\"session is expired\");\n    await clearUsersDb(expired);\n  }\n  return expired;\n}\n\nconst clearUsersDb = async (isExpired) => {\n  if (isExpired) {\n    await clearAllData('users');\n    console.log(\"Expired, clearing users\");\n  }\n  console.log(\"Not expired, not clearing users\");\n}\n\nexport { passwordFormat, encrypt, decrypt, isManager, checkPermissions, checkLogin, getSessionInfo, isSessionExpired };\n"]},"metadata":{},"sourceType":"module"}